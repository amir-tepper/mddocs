using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MdDoc.Model.XmlDocs
{
    internal class MemberIdLexerException : Exception
    {
        public MemberIdLexerException(string message) : base(message)
        {
        }
    }

    internal enum TokenKind
    {
        /// <summary>
        /// A token that indicates the type of identifier (T, M, P, F, E)
        /// </summary>
        IdentifierType,
        /// <summary>
        /// Acolon (':') token
        /// </summary>
        Colon,
        /// <summary>
        /// A dot ('.') token
        /// </summary>
        Dot,
        /// <summary>
        /// A name token (either a namespace, type or method name)
        /// </summary>
        Name,
        /// <summary>
        /// A backtick ('`') token
        /// </summary>
        Backtick,
        /// <summary>
        /// A double-backtick ('``') token
        /// </summary>
        DoubleBacktick,
        /// <summary>
        /// A number token
        /// </summary>
        Number,
        /// <summary>
        /// A opening parenthesis ('(') token
        /// </summary>
        OpenParenthesis,
        /// <summary>
        /// A closing parenthesis (')') token
        /// </summary>
        CloseParenthesis,
        /// <summary>
        /// A comma (',') token
        /// </summary>
        Comma,
        /// <summary>
        /// A opening brache ('{') token
        /// </summary>
        OpenBrace,
        /// <summary>
        /// A closing brace ('}') token
        /// </summary>
        CloseBrace,
        /// <summary>
        /// A tile ('~') token
        /// </summary>
        Tilde,
        /// <summary>
        /// A token indicating the end of the text to parse
        /// </summary>
        Eof
    }

    internal struct Token
    {
        public string Value { get; set; }

        public TokenKind Kind { get; set; }

        public Token(TokenKind kind, char value)
        {
            Kind = kind;
            Value = value.ToString();
        }

        public Token(TokenKind kind, string value)
        {
            Kind = kind;
            Value = value;
        }
    }

    /// <summary>
    /// Lexer for XML docs member ids
    /// </summary>
    /// <remarks>
    /// A lexer for member ids in XML documentation docs generated by the C# compiler as documented 
    /// here https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/xmldoc/processing-the-xml-file
    /// Used by <see cref="MemberIdParser"/>
    /// </remarks>
    internal class MemberIdLexer
    {
        private readonly string m_Text;        
        private int m_Position;


        private char Current => m_Position >= m_Text.Length ? '\0' : m_Text[m_Position];

        private char Next => m_Position + 1 >= m_Text.Length ? '\0' : m_Text[m_Position + 1];


        public MemberIdLexer(string input)
        {
            m_Text = input;
        }


        public IReadOnlyList<Token> GetTokens()
        {
            m_Position = 0;
            return EnumerateTokens().ToArray();
        }

        private IEnumerable<Token> EnumerateTokens()
        {
            // for an empry string, only return the EOF token
            if (Current == '\0')
            {
                yield return new Token(TokenKind.Eof, ""); 
                yield break;
            }

            // a identifier always start with a character identifiyng the type of identifier (type, field, method...)
            // followed by a colon            
            yield return ReadIdentifierTypeToken();

            if (Current != ':')
            {
                throw new MemberIdLexerException($"Expected ':' at position {m_Position}");
            }
            else
            {
                yield return new Token(TokenKind.Colon, ":");
                m_Position++;
            }

            //iterate over the input text
            while (Current != '\0')
            {
                // number => read as number token, names can contain digits but never start with a digit
                if (char.IsDigit(Current))
                {
                    yield return ReadNumberToken();
                    continue;
                }

                switch (Current)
                {
                    case '.':
                        yield return new Token(TokenKind.Dot, ".");
                        m_Position++;
                        break;

                    // for backtick, look ahead one character to detect a double-backtick token
                    case '`':
                        if(Next == '`')
                        {
                            yield return new Token(TokenKind.DoubleBacktick, "``");
                            m_Position += 2;
                        }
                        else
                        {
                            yield return new Token(TokenKind.Backtick, "`");
                            m_Position++;
                        }
                        break;

                    case '(':
                        yield return new Token(TokenKind.OpenParenthesis, "(");
                        m_Position++;
                        break;

                    case ')':
                        yield return new Token(TokenKind.CloseParenthesis, ")");
                        m_Position++;
                        break;

                    case '{':
                        yield return new Token(TokenKind.OpenBrace, "{");
                        m_Position++;
                        break;

                    case '}':
                        yield return new Token(TokenKind.CloseBrace, "}");
                        m_Position++;
                        break;

                    case ',':
                        yield return new Token(TokenKind.Comma, ",");
                        m_Position++;
                        break;

                    case '~':
                        yield return new Token(TokenKind.Tilde, "~");
                        m_Position++;
                        break;

                    default:
                        yield return ReadNameToken();
                        break;
                }
            }

            // return EOF token to signal the end of the text
            yield return new Token(TokenKind.Eof, "");
        }


        private Token ReadIdentifierTypeToken()
        {            
            switch (Current)
            {
                case 'T':
                case 'F':
                case 'P':
                case 'M':
                case 'E':
                    var token = new Token(TokenKind.IdentifierType, Current);
                    m_Position++;
                    return token;

                default:
                    throw new MemberIdLexerException("Member id must start with prefix indicating the member kind, expected T, F, P, M, or E");
            }
        }

        private Token ReadNameToken()
        {
            var resultBuilder = new StringBuilder();

            var startPosition = m_Position;
            while (Current != '\0')
            {
                if (Current == '.' ||
                    Current == '`' ||
                    Current == '(' ||
                    Current == ')' ||
                    Current == '{' ||
                    Current == '}' ||
                    Current == ','||
                    Current == '~')
                {
                    break;
                }

                if (Current == '#')
                {
                    resultBuilder.Append('.');
                }
                else
                {
                    resultBuilder.Append(Current);
                }

                m_Position++;
            }

            // names cannot be empty
            if (resultBuilder.Length == 0)
                throw new MemberIdLexerException($"Failed to read name at position '{startPosition}'");

            return new Token(TokenKind.Name, resultBuilder.ToString());
        }
        
        private Token ReadNumberToken()
        {
            var startPosition = m_Position;            
            while (Current != '\0' && char.IsDigit(Current))
            {
                m_Position++;
            }
            
            // numbers must contain at least one digit
            if (startPosition == m_Position)
                throw new MemberIdLexerException($"Failed to read number at position {startPosition}");
            
            return new Token(TokenKind.Number, m_Text.Substring(startPosition, m_Position - startPosition));
        }
    }
}
