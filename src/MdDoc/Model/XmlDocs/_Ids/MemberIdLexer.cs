using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MdDoc.Model.XmlDocs
{
    internal class MemberIdLexerException : Exception
    {
        public MemberIdLexerException(string message) : base(message)
        {
        }
    }

    internal enum TokenKind
    {
        /// <summary>
        /// A token that indicates the type of identifier (N, T, M, P, F, E)
        /// </summary>
        IdentifierType,
        /// <summary>
        /// A colon (':') token
        /// </summary>
        Colon,
        /// <summary>
        /// A dot ('.') token
        /// </summary>
        Dot,
        /// <summary>
        /// A name token (either a namespace, type or method name)
        /// </summary>
        Name,
        /// <summary>
        /// A backtick ('`') token
        /// </summary>
        Backtick,
        /// <summary>
        /// A double-backtick ('``') token
        /// </summary>
        DoubleBacktick,
        /// <summary>
        /// A number token
        /// </summary>
        Number,
        /// <summary>
        /// A opening parenthesis ('(') token
        /// </summary>
        OpenParenthesis,
        /// <summary>
        /// A closing parenthesis (')') token
        /// </summary>
        CloseParenthesis,
        /// <summary>
        /// A comma (',') token
        /// </summary>
        Comma,
        /// <summary>
        /// A opening brace ('{') token
        /// </summary>
        OpenBrace,
        /// <summary>
        /// A closing brace ('}') token
        /// </summary>
        CloseBrace,
        /// <summary>
        /// A tile ('~') token
        /// </summary>
        Tilde,
        /// <summary>
        /// A open square bracket ('[') token
        /// </summary>
        OpenSquareBracket,
        /// <summary>
        /// A close square bracket (']') token
        /// </summary>
        CloseSquareBracket,
        /// <summary>
        /// A token indicating the end of the text to parse
        /// </summary>
        Eof
    }

    internal struct Token 
    {
        public string Value { get; set; }

        public TokenKind Kind { get; set; }

        public Token(TokenKind kind, char value)
        {
            Kind = kind;
            Value = value.ToString();
        }

        public Token(TokenKind kind, string value)
        {
            Kind = kind;
            Value = value;
        }
    }

    /// <summary>
    /// Lexer for XML docs member ids
    /// </summary>
    /// <remarks>
    /// A lexer for member ids in XML documentation docs generated by the C# compiler as documented 
    /// here https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/xmldoc/processing-the-xml-file
    /// Used by <see cref="MemberIdParser"/>
    /// </remarks>
    internal class MemberIdLexer
    {
        private readonly string m_Text;        
        private int m_Position;


        private char Current => m_Position >= m_Text.Length ? '\0' : m_Text[m_Position];

        private char Next => m_Position + 1 >= m_Text.Length ? '\0' : m_Text[m_Position + 1];


        public MemberIdLexer(string input)
        {
            m_Text = input;
        }


        public IReadOnlyList<Token> GetTokens()
        {
            m_Position = 0;
            return EnumerateTokens().ToArray();
        }

        private IEnumerable<Token> EnumerateTokens()
        {
            //iterate over the input text
            while (Current != '\0')
            {                
                switch (Current)
                {
                    // number => read as number token, names can contain digits but never start with a digit
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                        yield return ReadNumberToken();
                        break;

                    case 'N' when m_Position == 0:
                    case 'T' when m_Position == 0:
                    case 'F' when m_Position == 0:
                    case 'E' when m_Position == 0:
                    case 'P' when m_Position == 0:
                    case 'M' when m_Position == 0:
                        yield return new Token(TokenKind.IdentifierType, Current);
                        m_Position++;
                        break;

                    case '.':
                        yield return new Token(TokenKind.Dot, ".");
                        m_Position++;
                        break;

                    // for backtick, look ahead one character to detect a double-backtick token
                    case '`':
                        if(Next == '`')
                        {
                            yield return new Token(TokenKind.DoubleBacktick, "``");
                            m_Position += 2;
                        }
                        else
                        {
                            yield return new Token(TokenKind.Backtick, "`");
                            m_Position++;
                        }
                        break;

                    case '(':
                        yield return new Token(TokenKind.OpenParenthesis, "(");
                        m_Position++;
                        break;

                    case ')':
                        yield return new Token(TokenKind.CloseParenthesis, ")");
                        m_Position++;
                        break;

                    case '{':
                        yield return new Token(TokenKind.OpenBrace, "{");
                        m_Position++;
                        break;

                    case '}':
                        yield return new Token(TokenKind.CloseBrace, "}");
                        m_Position++;
                        break;

                    case ',':
                        yield return new Token(TokenKind.Comma, ",");
                        m_Position++;
                        break;

                    case '[':
                        yield return new Token(TokenKind.OpenSquareBracket, "[");
                        m_Position++;
                        break;

                    case ']':
                        yield return new Token(TokenKind.CloseSquareBracket, "]");
                        m_Position++;
                        break;

                    case '~':
                        yield return new Token(TokenKind.Tilde, "~");
                        m_Position++;
                        break;

                    case ':':
                        yield return new Token(TokenKind.Colon, ":");
                        m_Position++;
                        break;

                    default:
                        yield return ReadNameToken();
                        break;
                }
            }

            // return EOF token to signal the end of the text
            yield return new Token(TokenKind.Eof, "");
        }

        private Token ReadNameToken()
        {
            var resultBuilder = new StringBuilder();

            var startPosition = m_Position;
            while (Current != '\0')
            {
                if (Current == '.' ||
                    Current == '`' ||
                    Current == '(' ||
                    Current == ')' ||
                    Current == '{' ||
                    Current == '}' ||
                    Current == '[' ||
                    Current == ']' ||
                    Current == ','||
                    Current == '~')
                {
                    break;
                }

                if (Current == '#')
                {
                    resultBuilder.Append('.');
                }
                else
                {
                    resultBuilder.Append(Current);
                }

                m_Position++;
            }

            // names cannot be empty
            if (resultBuilder.Length == 0)
                throw new MemberIdLexerException($"Failed to read name at position '{startPosition}'");

            return new Token(TokenKind.Name, resultBuilder.ToString());
        }
        
        private Token ReadNumberToken()
        {
            var startPosition = m_Position;            
            while (Current != '\0' && char.IsDigit(Current))
            {
                m_Position++;
            }
            
            // numbers must contain at least one digit
            if (startPosition == m_Position)
                throw new MemberIdLexerException($"Failed to read number at position {startPosition}");
            
            return new Token(TokenKind.Number, m_Text.Substring(startPosition, m_Position - startPosition));
        }
    }
}
