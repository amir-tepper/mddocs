using System;
using System.Collections.Generic;
using System.Linq;

namespace Grynwald.MdDocs.ApiReference.Model.XmlDocs
{
    /// <summary>
    /// Parser for XML Docs member ids
    /// </summary>
    /// <remarks>
    /// A parser that can pare member ids in XML documentation docs generated by the C# compiler as documented 
    /// here https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/xmldoc/processing-the-xml-file
    /// </remarks>
    // TODO: Add support for namespace ids
    internal class MemberIdParser
    {
        private readonly string m_Text;
        private readonly MemberIdLexer m_Lexer;
        private IReadOnlyList<Token> m_Tokens;
        private int m_Position;


        private Token Current => m_Position >= m_Tokens.Count ? m_Tokens[m_Tokens.Count - 1] : m_Tokens[m_Position];


        public MemberIdParser(string text)
        {
            m_Text = text;
            m_Lexer = new MemberIdLexer(text);
        }


        public MemberId Parse()
        {
            try
            {
                m_Tokens = m_Lexer.GetTokens();
            }
            catch (MemberIdLexerException e)
            {
                // rethrow lexer errors as parser errors
                throw new MemberIdParserException("Failed to parse input because of an lexer error", e);
            }
            m_Position = 0;

            // all ids start with a single char that indicates what type if identifier it is (type, method...)
            var kind = MatchToken(TokenKind.IdentifierType);
            MatchToken(TokenKind.Colon);

            switch (kind)
            {
                case "F":
                    return ParseFieldId();

                case "E":
                    return ParseEventId();

                case "T":
                    return ParseTypeId();

                case "M":
                    return ParseMethodId();

                case "P":
                    return ParsePropertyId();

                case "N":
                    return ParseNamespaceId();

                default:
                    // should not happen as for unknown tokens, MatchToken should already throw
                    throw new NotImplementedException();
            }
        }


        private NamespaceId ParseNamespaceId()
        {
            var nameSegments = ParseNameSegments();
            var namespaceId = new NamespaceId(String.Join(".", nameSegments));

            // all token should be parsed now
            MatchToken(TokenKind.Eof);

            return namespaceId;
        }

        private TypeId ParseTypeId()
        {
            // id always starts with a name            
            var nameSegments = ParseNameSegments();

            // optional part: number of type arguments for generic types
            var arity = ParseTypeArity();

            var namespaceName = String.Join(".", nameSegments.Take(nameSegments.Count - 1));
            var typeName = nameSegments[nameSegments.Count - 1];
            var type = CreateTypeId(namespaceName, typeName, arity);

            // if the type if followed by square brackets, the id refers to an array type
            // arrays of arrays are allowed, too
            type = ParseArraySuffix(type);

            // all token should be parsed now
            MatchToken(TokenKind.Eof);

            return type;
        }

        private FieldId ParseFieldId()
        {
            var (definingType, name) = ParseFieldOrEventId();
            return new FieldId(definingType, name);
        }

        private EventId ParseEventId()
        {
            var (definingType, name) = ParseFieldOrEventId();
            return new EventId(definingType, name);
        }

        private (TypeId definingType, string name) ParseFieldOrEventId()
        {
            // id always starts with a name                        
            var nameSegments = ParseNameSegments();

            // optional part: type arity
            var typeArity = ParseTypeArity();

            // for generic types, the name of the field or event follows after the arity
            if (typeArity != 0)
            {
                MatchToken(TokenKind.Dot);
                nameSegments.Add(MatchToken(TokenKind.Name));
            }

            // there shouldn't be anything left after that
            MatchToken(TokenKind.Eof);

            return CreateTypeIdFromMemberNameSegments(nameSegments, typeArity);
        }

        private MethodId ParseMethodId()
        {
            // id always starts with a name            
            var nameSegments = ParseNameSegments();

            // optional part: type arity
            var typeArity = ParseTypeArity();

            // for generic types, the name of the method follows after the arity
            if (typeArity != 0)
            {
                MatchToken(TokenKind.Dot);
                nameSegments.Add(MatchToken(TokenKind.Name));
            }

            // optional part: method arity
            var methodArity = ParseMethodArity();

            // optional part: parameter list
            var methodParameters = ParseParameterList();

            // optional part: return type (only used for overloads of implicit and explicit conversion)
            var methodReturnType = default(TypeId);
            if (TestAndMatchToken(TokenKind.Tilde))
            {
                methodReturnType = ParseTypeName();
            }

            // ensure we parsed all tokens
            MatchToken(TokenKind.Eof);

            var (definingType, methodName) = CreateTypeIdFromMemberNameSegments(nameSegments, typeArity);

            return new MethodId(definingType, methodName, methodArity, methodParameters, methodReturnType);
        }

        private PropertyId ParsePropertyId()
        {
            // id always starts with a name            
            var nameSegments = ParseNameSegments();

            // optional part: back-tick + number => arity of generic type
            var typeArity = ParseTypeArity();

            // for generic types, the name of the property follows after the arity
            if (typeArity != 0)
            {
                MatchToken(TokenKind.Dot);
                nameSegments.Add(MatchToken(TokenKind.Name));
            }

            // optional part: parameter list (used for indexers)
            var parameters = ParseParameterList();

            // ensure we parsed all tokens
            MatchToken(TokenKind.Eof);

            var (definingType, propertyName) = CreateTypeIdFromMemberNameSegments(nameSegments, typeArity);

            return new PropertyId(definingType, propertyName, parameters ?? Array.Empty<TypeId>());
        }


        private List<string> ParseNameSegments()
        {
            var nameSegments = new List<string>();

            // there must be at least one name segment
            nameSegments.Add(MatchToken(TokenKind.Name));

            // as long as there are more dots, consume more name segments
            while (Current.Kind == TokenKind.Dot)
            {
                MatchToken(TokenKind.Dot);
                nameSegments.Add(MatchToken(TokenKind.Name));
            }

            return nameSegments;
        }

        private TypeId ParseArraySuffix(TypeId elementType)
        {
            if (Current.Kind != TokenKind.OpenSquareBracket)
                return elementType;

            var type = elementType;
            while (Current.Kind == TokenKind.OpenSquareBracket)
            {
                MatchToken(TokenKind.OpenSquareBracket);

                var dimensions = ParseArrayDimensions();

                MatchToken(TokenKind.CloseSquareBracket);

                // wrap type into an array
                type = new ArrayTypeId(type, dimensions);
            }

            return type;
        }

        private int ParseArrayDimensions()
        {
            // the number of dimensions is the number of commas + 1
            var dimensions = 1;

            // optional part: lower bound and size for each dimension, separated by commas
            while (Current.Kind != TokenKind.CloseSquareBracket)
            {
                switch (Current.Kind)
                {
                    case TokenKind.Comma:
                        MatchToken(TokenKind.Comma);
                        dimensions++;
                        break;

                    // lower bound and size are optional
                    // if neither lower bound nor size is known, the colon is omitted as well
                    // this means the following sequences are possible
                    // - lowerBound:size
                    // - lowerBound:
                    // - :size
                    // Both lower bound and size are ignored as they are not required
                    // for identifying a type

                    // case ":size"
                    case TokenKind.Colon:
                        MatchToken(TokenKind.Colon);
                        MatchToken(TokenKind.Number);
                        break;

                    // case "lowerBound:size" and "lowerBound:"
                    case TokenKind.Number:
                        MatchToken(TokenKind.Number);
                        MatchToken(TokenKind.Colon);
                        // optional number token (for the case "lowerBound:")
                        TestAndMatchToken(TokenKind.Number);
                        break;

                    default:
                        throw UnexpectedToken(TokenKind.Comma, TokenKind.Colon, TokenKind.Number);
                }
            }

            return dimensions;
        }

        private IReadOnlyList<TypeId> ParseParameterList()
        {
            if (TestAndMatchToken(TokenKind.OpenParenthesis))
            {
                var parameters = ParseTypeNameList();
                MatchToken(TokenKind.CloseParenthesis);
                return parameters;
            }
            else
            {
                return Array.Empty<TypeId>();
            }
        }

        private IReadOnlyList<TypeId> ParseTypeNameList()
        {
            var parameters = new List<TypeId>();

            // there needs to be at least one type name in the list
            do
            {
                parameters.Add(ParseTypeName());
            }
            while (TestAndMatchToken(TokenKind.Comma));

            return parameters;
        }

        private TypeId ParseTypeName()
        {
            TypeId type;
            if (TestAndMatchToken(TokenKind.Backtick))
            {
                var index = int.Parse(MatchToken(TokenKind.Number));
                type = new GenericTypeParameterId(GenericTypeParameterId.MemberKind.Type, index);
            }
            else if (TestAndMatchToken(TokenKind.DoubleBacktick))
            {
                var index = int.Parse(MatchToken(TokenKind.Number));
                type = new GenericTypeParameterId(GenericTypeParameterId.MemberKind.Method, index);
            }
            else
            {
                var nameSegments = ParseNameSegments();

                // optional part: type arguments (enclosed by '{' and '}')
                var typeArguments = default(IReadOnlyList<TypeId>);
                if (TestAndMatchToken(TokenKind.OpenBrace))
                {
                    typeArguments = ParseTypeNameList();
                    MatchToken(TokenKind.CloseBrace);
                }

                var namespaceName = String.Join(".", nameSegments.Take(nameSegments.Count - 1));
                var typeName = nameSegments[nameSegments.Count - 1];


                if (typeArguments != null)
                {
                    type = new GenericTypeInstanceId(new NamespaceId(namespaceName), typeName, typeArguments);
                }
                else
                {
                    type = new SimpleTypeId(new NamespaceId(namespaceName), typeName);
                }
            }

            // optional part: array declaration
            // if the type if followed by square brackets, the id refers to an array type
            // arrays of arrays are allowed, too
            type = ParseArraySuffix(type);

            return type;
        }

        private int ParseTypeArity() =>
            TestAndMatchToken(TokenKind.Backtick) ? int.Parse(MatchToken(TokenKind.Number)) : 0;

        private int ParseMethodArity() =>
            TestAndMatchToken(TokenKind.DoubleBacktick) ? int.Parse(MatchToken(TokenKind.Number)) : 0;

        private string MatchToken(TokenKind kind)
        {
            if (Current.Kind == kind)
            {
                var value = Current.Value;
                m_Position++;
                return value;
            }
            else
            {
                throw UnexpectedToken(kind);
            }
        }

        private bool TestAndMatchToken(TokenKind kind)
        {
            if (Current.Kind == kind)
            {
                m_Position++;
                return true;
            }
            else
            {
                return false;
            }
        }

        private MemberIdParserException UnexpectedToken(params TokenKind[] expected)
        {
            return new MemberIdParserException($"Unexpected token. Expected {String.Join(",", expected)} but was {Current.Kind}");
        }

        private TypeId CreateTypeId(string namespaceName, string typeName, int arity)
        {
            if (arity > 0)
            {
                return new GenericTypeId(new NamespaceId(namespaceName), typeName, arity);
            }
            else
            {
                return new SimpleTypeId(new NamespaceId(namespaceName), typeName);
            }
        }

        private (TypeId definingType, string memberName) CreateTypeIdFromMemberNameSegments(IReadOnlyList<string> nameSegments, int typeArity)
        {
            // type member name needs at least two name segments (type name + field/event/property/method name)
            if (nameSegments.Count < 2)
                throw new MemberIdParserException("Invalid input, type member name requires name of defining type and member");

            var namespaceName = String.Join(".", nameSegments.Take(nameSegments.Count - 2));
            var typeName = nameSegments[nameSegments.Count - 2];
            var name = nameSegments[nameSegments.Count - 1];

            return (CreateTypeId(namespaceName, typeName, typeArity), name);
        }
    }
}
