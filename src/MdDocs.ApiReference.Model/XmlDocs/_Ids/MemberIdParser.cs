using System;
using System.Collections.Generic;
using System.Linq;

namespace Grynwald.MdDocs.ApiReference.Model.XmlDocs
{
    /// <summary>
    /// Parser for XML Docs member ids
    /// </summary>
    /// <remarks>
    /// A parser that can parse member ids in XML documentation docs generated by the C# compiler as documented 
    /// <see href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/xmldoc/processing-the-xml-file">here</see>.
    /// </remarks>
    internal class MemberIdParser
    {
        private readonly MemberIdLexer m_Lexer;
        private readonly IReadOnlyCollection<TypeId> m_OuterTypes;
        private IReadOnlyList<MemberIdToken> m_Tokens;
        private int m_Position;


        private MemberIdToken Current => m_Position >= m_Tokens.Count ? m_Tokens[m_Tokens.Count - 1] : m_Tokens[m_Position];

        /// <summary>
        /// Initializes a new instance of <see cref="MemberIdParser"/>
        /// </summary>
        /// <remarks>
        /// <para>
        /// Because the id of a nested type cannot be distinguished from the id of a non-nested type,
        /// a list of known non-nested ("outer types") needs to be passed in so that ids of
        /// nested types are parsed correctly.
        /// </para>
        /// <para>
        /// For example the id <c>T:Namespace.Class1.NestedClass</c>
        /// would be parsed into a type named <c>NestedClass</c> with a namespace <c>Namespace.Class1</c>.
        /// When the list of outer types contains the type <c>Namespace.Class1</c>, the id is parsed correctly.
        /// </para>
        /// </remarks>
        /// <param name="text">The id to be parsed</param>
        /// <param name="outerTypes">The list of outer / non-nested types in the assembly</param>
        public MemberIdParser(string text, IReadOnlyCollection<TypeId> outerTypes)
        {
            m_Lexer = new MemberIdLexer(text);
            m_OuterTypes = outerTypes ?? throw new ArgumentNullException(nameof(outerTypes));
            m_Tokens = Array.Empty<MemberIdToken>();
        }


        /// <summary>
        /// Parses the input into a <see cref="MemberId"/>.
        /// </summary>
        /// <exception cref="MemberIdParserException">Thrown when the input could not be parsed.</exception>
        public MemberId Parse()
        {
            try
            {
                m_Tokens = m_Lexer.GetTokens();
            }
            catch (MemberIdLexerException e)
            {
                // rethrow lexer errors as parser errors
                throw new MemberIdParserException("Failed to parse input because of an lexer error", e);
            }
            m_Position = 0;

            // all ids start with a single char that indicates what type if identifier it is (type, method...)
            var kind = MatchToken(MemberIdTokenKind.IdentifierType);
            MatchToken(MemberIdTokenKind.Colon);

            switch (kind)
            {
                case "F":
                    return ParseFieldId();

                case "E":
                    return ParseEventId();

                case "T":
                    return ParseTypeId();

                case "M":
                    return ParseMethodId();

                case "P":
                    return ParsePropertyId();

                case "N":
                    return ParseNamespaceId();

                default:
                    // should not happen as for unknown tokens, MatchToken should already throw
                    throw new NotImplementedException();
            }
        }


        private NamespaceId ParseNamespaceId()
        {
            var namespaceBuilder = new NamespaceIdBuilder();

            // there needs to be at least one name
            namespaceBuilder.AddNameSegment(MatchToken(MemberIdTokenKind.Name));

            // as long as there are more dots, consume more name segments
            while (TestAndMatchToken(MemberIdTokenKind.Dot))
            {
                namespaceBuilder.AddNameSegment(MatchToken(MemberIdTokenKind.Name));
            }

            // all tokens should be parsed now
            MatchToken(MemberIdTokenKind.Eof);

            return namespaceBuilder.ToNamespaceId();
        }

        private TypeId ParseTypeId()
        {
            // id always starts with a name            
            var nameSegments = ParseNameSegmentsWithArity();

            var typeIdBuilder = TypeIdBuilder.Create();
            foreach (var (name, arity) in nameSegments)
            {
                typeIdBuilder = typeIdBuilder
                    .AddNameSegment(name)
                    .SetArity(arity);

                if (m_OuterTypes.Contains(typeIdBuilder.ToTypeId()))
                {
                    typeIdBuilder = typeIdBuilder.BeginNestedType();
                }

            }

            var type = typeIdBuilder.ToTypeId();

            // if the type if followed by square brackets, the id refers to an array type
            // arrays of arrays are allowed, too
            type = ParseArraySuffix(type);

            // all token should be parsed now
            MatchToken(MemberIdTokenKind.Eof);

            return type;
        }

        private FieldId ParseFieldId()
        {
            var (definingType, name) = ParseMemberId();

            // there shouldn't be anything left after that
            MatchToken(MemberIdTokenKind.Eof);

            return new FieldId(definingType, name);
        }

        private EventId ParseEventId()
        {
            var (definingType, name) = ParseMemberId();

            // there shouldn't be anything left after that
            MatchToken(MemberIdTokenKind.Eof);

            return new EventId(definingType, name);
        }

        private MethodId ParseMethodId()
        {
            var (definingType, methodName) = ParseMemberId();

            // optional part: method arity
            var methodArity = ParseMethodArity();

            // optional part: parameter list
            var methodParameters = ParseParameterList();

            // optional part: return type (only used for overloads of implicit and explicit conversion)
            var methodReturnType = default(TypeId);
            if (TestAndMatchToken(MemberIdTokenKind.Tilde))
            {
                methodReturnType = ParseTypeName();
            }

            // ensure we parsed all tokens
            MatchToken(MemberIdTokenKind.Eof);

            return new MethodId(definingType, methodName, methodArity, methodParameters, methodReturnType);
        }

        private PropertyId ParsePropertyId()
        {
            // parse defining type and property name
            var (definingType, propertyName) = ParseMemberId();

            // optional part: parameter list (used for indexers)
            var parameters = ParseParameterList();

            // ensure we parsed all tokens
            MatchToken(MemberIdTokenKind.Eof);

            return new PropertyId(definingType, propertyName, parameters ?? Array.Empty<TypeId>());
        }


        private (TypeId definingType, string name) ParseMemberId()
        {
            // id always starts with a name
            var nameSegments = ParseNameSegmentsWithArity();

            // there need to be at least 2 name segments:
            // - The defining type (might be a single name if type is defined in global namespace)
            // - The name of the member (method, field, property, event)
            if (nameSegments.Count < 2)
                throw new MemberIdParserException("Invalid input, type member name requires name of defining type and member");

            // the last segment is the name of the member
            var lastSegment = nameSegments.Last();

            // there mustn't be any (type) arity on the last segment
            // (method type parameters are handled separately in ParseMethoodId())
            if (lastSegment.arity != 0)
                throw new MemberIdParserException("Invalid input, unexpected arity suffix on member name");

            // all segments but the last are part of the name of the defining type
            nameSegments = nameSegments.Take(nameSegments.Count - 1).ToList();

            var typeBuilder = TypeIdBuilder.Create();
            foreach (var (name, arity) in nameSegments)
            {
                typeBuilder = typeBuilder
                    .AddNameSegment(name)
                    .SetArity(arity);

                if (m_OuterTypes.Contains(typeBuilder.ToTypeId()))
                {
                    typeBuilder = typeBuilder.BeginNestedType();
                }
            }

            return (typeBuilder.ToTypeId(), lastSegment.name);
        }

        private List<(string name, int arity)> ParseNameSegmentsWithArity()
        {
            var segments = new List<(string, int)>
            {
                // there must be at least one name segment
                (MatchToken(MemberIdTokenKind.Name), ParseTypeArity())
            };

            // as long as there are more dots, consume more name segments
            while (Current.Kind == MemberIdTokenKind.Dot)
            {
                MatchToken(MemberIdTokenKind.Dot);

                var name = MatchToken(MemberIdTokenKind.Name);
                var arity = ParseTypeArity();
                segments.Add((name, arity));
            }

            return segments;
        }

        private TypeId ParseArraySuffix(TypeId elementType)
        {
            if (Current.Kind != MemberIdTokenKind.OpenSquareBracket)
                return elementType;

            var type = elementType;
            while (Current.Kind == MemberIdTokenKind.OpenSquareBracket)
            {
                MatchToken(MemberIdTokenKind.OpenSquareBracket);

                var dimensions = ParseArrayDimensions();

                MatchToken(MemberIdTokenKind.CloseSquareBracket);

                // wrap type into an array
                type = new ArrayTypeId(type, dimensions);
            }

            return type;
        }

        private int ParseArrayDimensions()
        {
            // the number of dimensions is the number of commas + 1
            var dimensions = 1;

            // optional part: lower bound and size for each dimension, separated by commas
            while (Current.Kind != MemberIdTokenKind.CloseSquareBracket)
            {
                switch (Current.Kind)
                {
                    case MemberIdTokenKind.Comma:
                        MatchToken(MemberIdTokenKind.Comma);
                        dimensions++;
                        break;

                    // lower bound and size are optional
                    // if neither lower bound nor size is known, the colon is omitted as well
                    // this means the following sequences are possible
                    // - lowerBound:size
                    // - lowerBound:
                    // - :size
                    // Both lower bound and size are ignored as they are not required
                    // for identifying a type

                    // case ":size"
                    case MemberIdTokenKind.Colon:
                        MatchToken(MemberIdTokenKind.Colon);
                        MatchToken(MemberIdTokenKind.Number);
                        break;

                    // case "lowerBound:size" and "lowerBound:"
                    case MemberIdTokenKind.Number:
                        MatchToken(MemberIdTokenKind.Number);
                        MatchToken(MemberIdTokenKind.Colon);
                        // optional number token (for the case "lowerBound:")
                        TestAndMatchToken(MemberIdTokenKind.Number);
                        break;

                    default:
                        throw UnexpectedToken(MemberIdTokenKind.Comma, MemberIdTokenKind.Colon, MemberIdTokenKind.Number);
                }
            }

            return dimensions;
        }

        private IReadOnlyList<TypeId> ParseParameterList()
        {
            if (TestAndMatchToken(MemberIdTokenKind.OpenParenthesis))
            {
                var parameters = ParseTypeNameList();
                MatchToken(MemberIdTokenKind.CloseParenthesis);
                return parameters;
            }
            else
            {
                return Array.Empty<TypeId>();
            }
        }

        private IReadOnlyList<TypeId> ParseTypeNameList()
        {
            var parameters = new List<TypeId>();

            // there needs to be at least one type name in the list
            do
            {
                parameters.Add(ParseTypeName());
            }
            while (TestAndMatchToken(MemberIdTokenKind.Comma));

            return parameters;
        }

        private TypeId ParseTypeName()
        {
            TypeId type;
            if (TestAndMatchToken(MemberIdTokenKind.Backtick))
            {
                var index = Int32.Parse(MatchToken(MemberIdTokenKind.Number));
                type = new GenericTypeParameterId(GenericTypeParameterId.MemberKind.Type, index);
            }
            else if (TestAndMatchToken(MemberIdTokenKind.DoubleBacktick))
            {
                var index = Int32.Parse(MatchToken(MemberIdTokenKind.Number));
                type = new GenericTypeParameterId(GenericTypeParameterId.MemberKind.Method, index);
            }
            else
            {
                var typeIdBuilder = TypeIdBuilder.Create();

                // there needs to be at least one name segment
                typeIdBuilder = typeIdBuilder.AddNameSegment(MatchToken(MemberIdTokenKind.Name));

                // consume all name tokens as long as the current token is a '.'
                // A open brace '{' indicates the start of a list of type arguments
                while (TestToken(MemberIdTokenKind.Dot, MemberIdTokenKind.OpenBrace))
                {
                    if (TestAndMatchToken(MemberIdTokenKind.Dot))
                    {
                        // match a single name token and append it to the current type name
                        var name = MatchToken(MemberIdTokenKind.Name);
                        typeIdBuilder = typeIdBuilder.AddNameSegment(name);

                        if (m_OuterTypes.Contains(typeIdBuilder.ToTypeId()))
                        {
                            typeIdBuilder = typeIdBuilder.BeginNestedType();
                        }
                    }
                    else if (TestAndMatchToken(MemberIdTokenKind.OpenBrace))
                    {
                        // parse list of type arguments
                        var typeArguments = ParseTypeNameList();
                        typeIdBuilder = typeIdBuilder.SetTypeArguments(typeArguments);

                        if (m_OuterTypes.Contains(typeIdBuilder.ToTypeId()))
                        {
                            typeIdBuilder = typeIdBuilder.BeginNestedType();
                        }

                        // type argument list must be followed by a '}'
                        MatchToken(MemberIdTokenKind.CloseBrace);
                    }
                    else
                    {
                        // should never happen
                        throw new InvalidOperationException();
                    }
                }

                type = typeIdBuilder.ToTypeId();
            }

            // optional part: array declaration
            // if the type if followed by square brackets, the id refers to an array type
            // arrays of arrays are allowed, too
            type = ParseArraySuffix(type);

            // optional suffix: @
            // if the type is followed by an '@' the parameter is being parsed by reference
            // (methods with 'out' or 'ref' parameter)

            if (TestAndMatchToken(MemberIdTokenKind.At))
            {
                type = new ByReferenceTypeId(type);
            }

            return type;
        }

        private int ParseTypeArity() =>
            TestAndMatchToken(MemberIdTokenKind.Backtick) ? Int32.Parse(MatchToken(MemberIdTokenKind.Number)) : 0;

        private int ParseMethodArity() =>
            TestAndMatchToken(MemberIdTokenKind.DoubleBacktick) ? Int32.Parse(MatchToken(MemberIdTokenKind.Number)) : 0;

        private string MatchToken(MemberIdTokenKind kind)
        {
            if (Current.Kind == kind)
            {
                var value = Current.Value;
                m_Position++;
                return value;
            }
            else
            {
                throw UnexpectedToken(kind);
            }
        }

        private bool TestAndMatchToken(MemberIdTokenKind kind)
        {
            if (Current.Kind == kind)
            {
                m_Position++;
                return true;
            }
            else
            {
                return false;
            }
        }

        private bool TestToken(MemberIdTokenKind kind1, MemberIdTokenKind kind2)
        {
            return Current.Kind == kind1 || Current.Kind == kind2;
        }

        private MemberIdParserException UnexpectedToken(params MemberIdTokenKind[] expected)
        {
            return new MemberIdParserException($"Unexpected token. Expected {String.Join(",", expected)} but was {Current.Kind}");
        }
    }
}
